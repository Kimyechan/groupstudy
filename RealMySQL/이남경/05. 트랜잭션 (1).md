# 05. 트랜잭션

날짜: 2022/07/28  
분류: 정리  
설명: Real Mysql 4번째 스터디 목요일 리딩 & 토론  
페이지: 155 ~ 166

# 트랜잭션

작업의 **완전성**을 보장한다

문제 발생 시, **일부만 적용되는 현상이 발생하지 않게 한다**

### # MyISAM vs InnoDB의 처리 방식

똑같은 레코드 (3) 를 각각 1건씩 저장한 후 AUTO-COMMIT 모드에서 각 테이블에서 실행해보자.

그 이후, (1), (2), (3)이라는 값을 각 테이블에 넣으면 결과는 어떻게 될까 ?

- **정답**

  두 INSERT 문 모두 PK 중복으로 인해 쿼리가 싫패하지만, MyISAM 테이블에는 1, 2가 INSERT된 상태로
  남지만, InnoDB는 쿼리 중 일부라도 오류가 발생하면 전체를 원래 상태로 만든다

- **게시물을 작성하고 서버에서 처리하는 내용 순서**
  1. 처리 시작
  2. 로그인 여부 확인
  3. 게시물 내용 오류 여부 확인
  4. 첨부로 업로드된 파일 확인 및 저장
     1. **데이터베이스 커넥션 생성**
     2. **트랜잭션 시작**
  5. 게시물 내용 DBMS에 저장
  6. 첨부 파일 정보를 DBMS에 저장
     1. **트랜잭션 종료**
  7. 저장된 내용 조회
     - 단순 조회이므로 트랜잭션에 포함될 필요 업
  8. **등록에 대한 알림 메일 발송**
     1. **트랜잭션 시작**
     - 네트워크를 통해 통신하는 것과 같은 작업은 DBMS 트랜잭션 내에서 제거하는 것이 좋다
  9. 알림 발송 이력 DBMS에 저장
     1. **트랜잭션 종료 (COMMIT)**
     2. 데이터베이스 커넥션 반납
  10. 처리 완료
  **프로그램의 코드가 데이터베이스 커넥션을 가지고 있는 범위와 트랜잭션이 활성화돼 있는 프로그램의 범위를 최소화 해야한다**

### # MySQL 엔진의 잠금

- **스토리지 엔진 레벨**과 **MySQL 엔진 레벨**로 나눌 수 있다
  - MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미친다
  - 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지는 않는다

1. **글로벌 락**
   - MySQL 제공하는 잠금 중 가장 범위가 크다
   - SELECT를 제외한 대부분의 DDL문장이나 DML문장을 실행하는 경우 글로벌 락이 해제될 때까지 대기
   - 여러 DB에 존재하는 MyISAM이나 MEMORY 테이블에 대해 mysqldump로 일관된 백업을 받아야 할 때는 글로벌 락을 사용해야 한다
   - MySQL 8.0버전부터는 Xtrabackup이나 Enterprise Backup같은 백업 툴들의 안정적인 실행을 위해
     백업 락이 도입됐다
   - 백업 락을 획득하면 모든 세션에서 테이블의 스키마나 사용자의 인증 고나련 정보를 변경할 수 없다
     - 일반적인 테이블의 데이터 변경은 허용된다
   - 일반적 MySQL 서버의 구성은 **소스 서버**와 **레플리카 서버**로 구성
     - 주로 백업은 레플리카 서버에서 실행
     - 레플리카 서버에서 백업 실행중에 소스 서버에 문제가 생기면 레플리카 서버의 데이터가
       최신 상태가 될 때까지 서비스를 멈춰야 할 수도 있다 - 오랜 시간 백업에 시간을 쓰던 와중, DDL 명령 하나로 인해 백업이 실패한다면 ?
2. **테이블 락**
   - 개별 테이블 단위로 설정되는 잠금
   - InnoDB 테이블의 경우 스토리지 엔진 차원에서 **레코드 기반의 잠금**을 제공하기 때문에
     단순한 데이터 변경 쿼리로 인해 묵시적인 테이블 락이 설정되지는 않는다 - **대부분의 DML에서는 무시되고 DDL의 경우만 영향을 미친다**
3. **네임드 락**

   - GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다
     - 테이블이나 레코드, AUTO_INCREMENT와 같은 DB 객체가 대상이 아니다
     - **단순히 사용자가 지정한 문자열에 대해 획득하고 반납하는 잠금**
   - DB 서버 1대에 5대의 웹 서버가 접속해서 서비스하는 상황에서 5대의 웹 서버가 어떤 정보를
     동기화해야 하는 요건처럼 여러 클라이언트가 상호 동기화를 처리해야 할 때 네임드 락을 이용한다
   - 많은 레코드를 변경하는 쿼리는 데드락의 원인이 되곤 한다
     - 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 네임드 락을 걸고 쿼리를 실행하면
       아주 간단히 해결할 수 있다
     ```sql
     SELECT GET_LOCK('mylock_1', 10);
     -- // mylock_1에 대한 작업 실행

     SELECT GET_LOCK('mylock_2', 10);
     -- // mylock_2에 대한 작업 실행

     SELECT RELEASE_LOCK('mylock_2');
     SELECT RELEASE_LOCK('mylock_1');

     SELECT RELEASE_ALL_LOCKS();
     ```

4. **메타데이터 락**
   - **데이터베이스 객체의 이름이나 구조를 변경하는 경우에 획득하는 잠금**
   - 명시적으로 획득하는 것이 아닌 자동으로 획득하는 **잠금**이다
